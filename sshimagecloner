#!/usr/bin/python3
'''ssh image cloner, to clone images from remote host over ssh'''

###############################################################################
##                             ssh image cloner                              ##
##                                                                           ##
## Python program to clone images from remote host over ssh                  ##
## Author: mikali-ri                                                         ##
## Created: 2021-11-01                                                       ##
## License: GNU General Public License v3                                    ##
##                                                                           ##
###############################################################################


###############################################################################
## Imports                                                                   ##
###############################################################################
import os
import sys
import codecs
import datetime
import getopt
import collections
import subprocess
import shlex
import yaml
from yaml.scanner import ScannerError



###############################################################################
## Own modules                                                               ##
###############################################################################
import helpers.logger as logger
import helpers.filesystemchecks as fschecks


###############################################################################
## My own custom classes                                                     ##
###############################################################################

#------------------------------------------------------------------------------
# Class for writing the logs, this handles the log levels etc.
#------------------------------------------------------------------------------
class LogWriter:
    '''A simple class to handle the verbosity and log writing'''

    def __init__(self, log_object, level, written, test):
        self.log = log_object
        self.log_level = level
        self.is_log_written = written
        if self.is_log_written and not test:
            with self.log.log_writer() as log_obj:
                log_obj.write_starting_row('Logging initiated, log level set to ' \
                     + str(self.log_level))


    def write(self, message, msgtype = 'N'):
        '''write a message to the log according to level etc.'''
        # if write_log is not set to True, do nothing.
        if not self.is_log_written:
            return

        if msgtype == 'E':
            with self.log.log_writer() as log_obj:
                log_obj.write_log(message, msgtype)
        elif msgtype == 'D' and self.log_level >= 2:
            with self.log.log_writer() as log_obj:
                log_obj.write_log(message, msgtype)
        elif msgtype == 'I' and self.log_level >= 1:
            with self.log.log_writer() as log_obj:
                log_obj.write_log(message, msgtype)
        elif msgtype == 'N':
            with self.log.log_writer() as log_obj:
                log_obj.write_log(message, msgtype)

        return


###############################################################################
## Constants                                                                 ##
###############################################################################

# config file is expected to be in the working directory
CONFIG_FILE_PATH = './sshimagecloner.yaml'


###############################################################################
## Main executable code                                                      ##
###############################################################################

def main(args):
    '''Main function to execute the code'''

    # Error count and message; used throughout the code.
    e_cnt = 0
    e_msg = ''

    # Parse and validate arguments (from command line), if any
    e_cnt, e_msg, cmd_args = parse_cmd_arguments(args)
    if e_cnt > 0:
        sys.exit(e_msg)

    # FIXME change so that there is no separate validation, but each argument is validated after parsing
    # and there is a small function for each parsing.
    e_cnt, e_msg, cmd_args = validate_and_fix_cmd_arguments(cmd_args)
    if e_cnt > 0:
        sys.exit('Error in command line arguments:\n' + e_msg)


    # Read and parse the configuration file
    if cmd_args.conf_file is None:
        if fschecks.file_exists(CONFIG_FILE_PATH):
            e_cnt, e_msg, conf, all_backups = parse_config_file(CONFIG_FILE_PATH)
        else:
            sys.exit('Configuration file ' + CONFIG_FILE_PATH + ' does not exist!')
    else:
        e_cnt, e_msg, conf, all_backups = parse_config_file(cmd_args.conf_file)

    # End execution if errors in parsing config file
    if e_cnt > 0:
        print('Errors in parsing the configuration file:\n')
        print(e_msg)
        sys.exit(1)

    # TODO Clean the parse_config_file function, only focus on parsing there

    # TODO Create a validate_config_params function, which validates the inputs to allowed values
    # stop execution with sys.exit(1) if problems in validation
    # again, files and folders must exist, except for log file, but log folder must be writable

    # If run as configtest, end process here
    if cmd_args.configtest:
        print('Config file content seems to be OK!')
        sys.exit(0)

    # Set up logging
    log = None
    my_log = None
    if cmd_args.testrun:
        log = logger.Logger(os.devnull, True)
        my_log = LogWriter(log, 0, True, True)
    else:
        log = logger.Logger(conf.log_file, cmd_args.verbose)
        my_log = LogWriter(log, conf.log_level, conf.is_log_written, False)

    my_log.write('All arguments and parameters parsed successfully, found ' \
        + str(len(all_backups)) + ' backups from config file', 'D')

    my_log.write('Command line arguments are:', 'D')
    my_log.write(str(cmd_args), 'D')
    my_log.write('Configuration parameters are:', 'D')
    my_log.write(str(conf), 'D')
    my_log.write('Backups and parameters are:', 'D')
    my_log.write(str(all_backups), 'D')


    # Actual execution starts from here
    my_log.write('Start to execute backups', 'D')

    # Compare the command line arguments with config file backups
    backups_to_process = {}
    if len(cmd_args.cmd_backups) > 0:
        e_cnt, e_msg, backups_to_process = select_for_processing(cmd_args.cmd_backups, all_backups)
    else:
        backups_to_process = all_backups

    if e_cnt > 0:
        my_log.write(e_msg, 'E')
        print(e_msg)
        return

    my_log.write(str(len(backups_to_process)) + ' backups to be processed', 'I')


    # If target_folder is given from command line, then replace it for all backups to be processed
    if cmd_args.target_folder is not None:
        backups_to_process = replace_target_folder(backups_to_process, cmd_args.target_folder)

    # TODO Fix below, only the backup specific folder should be created, not the path before it

    # Process through the selected backups
    for key, backup in backups_to_process.items():
        # Check if the backup-specific folder exists, if not create
        e_cnt, e_msg, path = prepare_path(conf.root_folder,
            backup.target_folder,
            my_log,
            cmd_args.testrun)
        if  e_cnt > 0:
            my_log.write(key + ': ' + e_msg, 'E')
            print(e_msg)
            return
        # Run the backup
        e_cnt, e_msg = run_backup(backup, path, my_log, cmd_args.testrun)
        if e_cnt > 0:
            my_log.write(key + ': ' + e_msg, 'E')
            print(e_msg)
            return

    # TODO Loop through all backups, and remove those which exceed the allowed count

    # End of def main(args)



def parse_cmd_arguments(arg):
    '''Parse command line arguments and return them as namedtuple'''

    usage = 'Usage: sshimagecloner [-h | --help] [-t | --test] [-v] \n' \
        + '[-c | --conffile configfile] [-f | --folder folder] \n' \
        + '[backupname_1] [backupname_2] [backupname...n]'

    err_count = 0
    msg = ''

    # Try to read the options and arguments from command line input
    try:
        opts, args = getopt.getopt(arg, 'htc:f:v', ['help', 'test', 'conffile=', 'folder='])
    except getopt.GetoptError:
        err_count += 1
        msg += '[ERROR] Could not parse command line options, possibly unrecognized option\n'
        msg += usage
        return err_count, msg, None

    # Process the options given.
    conf_file = None
    target_folder = None
    verbose = False
    testrun = False

    for opt, val in opts:
        if opt == '-v':
            verbose = True
        elif opt in ('-h', '--help'):
            print(usage)
            sys.exit(0)
        elif opt in ('-c', '--conffile'):
            conf_file = val
        elif opt in ('-f', '--folder'):
            target_folder = val
        elif opt in ('-t', '--test'):
            testrun = True
        else:
            err_count += 1
            msg += 'Unrecognized option'

    # Process the arguments given.
    configtest = False
    cmd_backups = {}
    for val in args:
        if val == 'configtest':
            configtest = True
        else:
            cmd_backups[val] = val

    Arguments = collections.namedtuple('Arguments',
    ['conf_file', 'target_folder', 'verbose', 'configtest', 'cmd_backups', 'testrun'])
    arguments = Arguments(conf_file, target_folder, verbose, configtest, cmd_backups, testrun)
    return err_count, msg, arguments

    # End of def parse_cmd_arguments(arg)


def validate_and_fix_cmd_arguments(arguments):
    '''Validates (relevant) arguments from commandline arguments.
    Replaces file and folder arguments with full path.'''
    err_count = 0
    msg = ''
    args = arguments

    if args.target_folder is not None:
        if fschecks.folder_exists(args.target_folder):
            if fschecks.is_folder_writable(args.target_folder):
                args = args._replace(target_folder = os.path.realpath(args.target_folder))
            else:
                err_count += 1
                msg += 'Target folder ' + args.target_folder + ' cannot be written in\n'
        else:
            err_count += 1
            msg += 'Target folder ' + args.target_folder + ' does not exist\n'

    if args.conf_file is not None:
        if fschecks.file_exists(args.conf_file):
            args = args._replace(conf_file = os.path.realpath(args.conf_file))
        else:
            err_count += 1
            msg += 'Configuration file ' + args.conf_file + ' does not exist\n'

    return err_count, msg, args

    # End of def validate_and_fix_cmd_arguments(args)


def parse_config_file(path):
    '''Parse config file and return Configuration namedtuple object and backups -list'''
    msg = ''
    err_count = 0

    yaml_conf = {}

    # Try to read the config file, exit if it foes not work
    try:
        with codecs.open(path, 'r', 'utf-8') as config_file:
            yaml_conf = yaml.load(config_file, Loader=yaml.FullLoader)
    except PermissionError:
        sys.exit('ERROR! Can not open configuration file for reading. Check file permissions')
    except ScannerError:
        sys.exit('ERROR! Configuration file could not be read in, check yaml syntax')


    # FIRST PARSE THE GENERAL CONFIGURATION
    general_config = {}
    if 'general' in yaml_conf:
        general_config = yaml_conf['general']
    else:
        err_count += 1
        msg += '[ERROR] general -section is missing from config file\n'


    # Default values of the variables from config file
    log_file = None
    log_level = 0
    is_log_written = False
    root_folder = None
    folder_naming = 'backupdir'
    versions = 2

    #Check through all the parameters needed.
    if 'log_file' in general_config:
        log_file = general_config['log_file']
        is_log_written = True

    if 'log_level' in general_config:
        log_level = general_config['log_level']

    if 'backup_root_folder' in general_config:
        if not os.path.exists(general_config['backup_root_folder']):
            err_count += 1
            msg += '[ERROR] backup_root_folder does not exist\n'
        # FIXME Check that the backup root folder is writable!!
        root_folder = general_config['backup_root_folder']
    else:
        err_count += 1
        msg += '[ERROR] Parameter backup_root_folder not set in config file\n'

    if 'folder_naming' in general_config:
        folder_naming = general_config['folder_naming']

    if 'versions' in general_config:
        versions = general_config['versions']

    Configuration = collections.namedtuple('Config',
    ['log_file', 'log_level', 'is_log_written', 'root_folder', 'folder_naming', 'versions'])

    conf = Configuration(log_file, log_level, is_log_written, root_folder, folder_naming, versions)


    # THEN PARSE THE BACKUP DETAILS
    backup_config = {}
    if 'backups' in yaml_conf:
        backup_config = yaml_conf['backups']
    else:
        err_count += 1
        msg += '[ERROR] backups -section is missing from config file\n'


    if len(backup_config) == 0:
        err_count += 1
        msg += '[ERROR] No backups specified in config file\n'

    all_backups = {}
    Backup = collections.namedtuple('Backup',
    ['name', 'remote_login', 'remote_host', 'remote_file',
    'target_file', 'target_folder', 'block_size'])

    for key in backup_config:
        try:
            r_l = backup_config[key]['remote_login']
        except KeyError:
            r_l = ''
            err_count += 1
            msg += '[ERROR] remote_login not specified for backup: ' + key + '\n'
        try:
            r_h = backup_config[key]['remote_host']
        except KeyError:
            r_h = ''
            err_count += 1
            msg += '[ERROR] remote_host not specified for backup: ' + key + '\n'
        try:
            r_f = backup_config[key]['remote_file']
        except KeyError:
            r_f = ''
            err_count += 1
            msg += '[ERROR] remote_file not specified for backup: ' + key + '\n'
        try:
            t_f = backup_config[key]['target_file']
        except KeyError:
            t_f = ''
            err_count += 1
            msg += '[ERROR] target_file not specified for backup: ' + key + '\n'
        try:
            b_s = backup_config[key]['block_size']
        except KeyError:
            b_s = ''
            err_count += 1
            msg += '[ERROR] block_size not specified for backup: ' + key + '\n'

        all_backups[key] = Backup(key, r_l, r_h, r_f, t_f, key, b_s)


    return err_count, msg, conf, all_backups
    # End of def parse_config_file(path)


def validate_and_fix_config_file_parameters(conf_nt, backups_nt):
    '''Validate the parameters parsed from configuration file
    Replace files and folders with full path.'''

    err_count = 0
    msg = ''

    conf = conf_nt
    backups = backups_nt

    if conf.log_file is not None:
        if fschecks.file_exists(conf.log_file):
            if fschecks.is_file_writable(conf.log_file):
                conf = conf._replace(log_file = os.path.realpath(conf.log_file))
            else:
                err_count += 1
                msg += 'Log file ' + conf.log_file + ' is not writable'
        else:
            log_folder = fschecks.get_files_folder(conf.log_file)
            if fschecks.is_folder_writable(log_folder):
                conf = conf._replace(log_file = os.path.realpath(conf.log_file))
            else:
                err_count += 1
                msg += 'Log file does not exist and folder ' + log_folder + ' is not writable\n'

    # TODO finalize the functionality here!!

    return err_count, msg, conf, backups

    # End of def validate_config_file_parameters(conf, backups)

def select_for_processing(cmdback, allback):
    '''Select the backups to be processed based on cmdline arguments.'''
    err_count = 0
    msg = ''
    backups_to_process = {}
    for key in cmdback:
        if key in allback.keys():
            backups_to_process[key] = allback[key]
        else:
            err_count += 1
            msg += 'Backup: ' + key + ' not found from config file, aborting\n'

    return err_count, msg, backups_to_process
    # Enf of def select_for_processing(cmdback, allback)


# Method to replace the target folder of the backups.
def replace_target_folder(backups, folder):
    '''Function to replace the target folder'''

    for key, value in backups.items():
        backups[key] = value._replace(target_folder = folder)

    return backups
    # End of def replace_target_folder(backups, folder)


# Method to create (if needed) the full backup path and return that.
def prepare_path(root_path, folder, log, test):
    '''Function to return the full backup path, and create if it does not exist'''
    err_count = 0
    msg = ''

    backup_folder = root_path + '/' + folder

    if os.path.isdir(backup_folder):
        return 0, '', backup_folder
    else:
        if os.path.exists(backup_folder):
            err_count += 1
            msg += 'Backup path ' + backup_folder + ' already exists, but is not a directory'
            return err_count, msg, ''
        else:
            try:
                # FIXME Do not create the full structure, exit if root path does not exist!!
                log.write('Create the full directory stucture', 'D')
                log.write('mkdir -p' + backup_folder, 'N')
                if not test:
                    os.makedirs(backup_folder)
            except PermissionError:
                err_count += 1
                msg += 'Cannot create folder: ' + backup_folder + ', no access rights'
                return err_count, msg, ''

    return err_count, msg, backup_folder

    # End of def prepare_path(root_path, folder, log, test)

# Method to run one backup
def run_backup(backup, path, log, test):
    '''Function to process one backup'''
    err_count = 0
    msg = ''

    if backup.remote_host == 'localhost':
        err_count, msg = run_local_backup(backup, path, log, test)
    else:
        err_count, msg = run_remote_backup(backup, path, log, test)

    return err_count, msg
    # End of def def run_backup(backup, path, log, test)


# Method to run one local backup
def run_local_backup(backup, path, log, test):
    '''Function to process one backup from local machine'''
    err_count = 0
    msg = ''

    log.write('Starting to process localhost ' + backup.name + ' : ' + backup.remote_file, 'I')

    # Construct the read command
    readcmd = '/usr/bin/sudo /usr/bin/dd if='+ backup.remote_file + ' bs=' + backup.block_size

    log.write(backup.name + ' read command:', 'D')
    log.write(readcmd, 'D')

    # Create the target filename, full path. ._tmp -extension is used during the write
    timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S_')
    target_file = path + '/' + timestamp + backup.target_file
    target_file_tmp = path + '/' + timestamp + backup.target_file + '._tmp'

    # Construct the write part of overall dd-command.
    gzipcmd = '/usr/bin/gzip -4'

    log.write(backup.name + ' gzip command:', 'D')
    log.write(gzipcmd, 'D')

    log.write('Full copy command:', 'D')
    log.write(readcmd + ' | ' + gzipcmd + ' > ' + target_file, 'N')

    # Split the command line options / process commands for subprocess.Popen command
    readsplit = shlex.split(readcmd)
    gzipsplit = shlex.split(gzipcmd)

    readproc = None
    gzipproc = None
    linestoprint = []
    if not test:
        try:
            outputfile = open(target_file_tmp, 'wb')
            # Start the process providing the read stream
            readproc = subprocess.Popen(readsplit,
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE)

            # Pipe the read streams output to write streams input
            gzipproc = subprocess.Popen(gzipsplit,
            stdin=readproc.stdout,
            stdout=outputfile,
            stderr=subprocess.PIPE)

            # Wait until the writing process finishes, and flush everything.
            gzipproc.wait()
            outputfile.flush()
            outputfile.close()

            linestoprint = readproc.stderr.readlines()
        except OSError as err:
            err_count += 1
            msg += 'Something went wrong with the read and write processes'
            print(err)
            return err_count, msg

    # Rename the target file to standard name.
    log.write('Renaming ' + target_file_tmp + ' to ' + target_file, 'D')
    log.write('mv ' + target_file_tmp + ' ' + target_file, 'N')
    if not test:
        os.rename(target_file_tmp, target_file)


    log.write(backup.name + ' : ' + backup.remote_file + ' successfully' \
        + 'backed up as ' + target_file, 'I')

    log.write('with following dd statistics', 'D')
    for line in linestoprint:
        log.write(line.decode('utf-8'), 'D')


    return err_count, msg
    # End of def run_local_backup(backup, path, log, test)


# Method to run one remote backup
def run_remote_backup(backup, path, log, test):
    '''Function to process one backup from a remote machine.'''
    err_count = 0
    msg = ''

    log.write('Starting to process remote host ' + backup.name + ' : ' + backup.remote_file, 'I')

    # Construct the "reading" part of the dd + gzip command
    readcmd = '/usr/bin/ssh ' + backup.remote_login + '@' + backup.remote_host \
        + ' "/usr/bin/sudo /usr/bin/dd if='+ backup.remote_file + ' bs=' + backup.block_size \
        + ' | /usr/bin/gzip -4 -"'

    log.write(backup.name + ' read command:', 'D')
    log.write(readcmd, 'D')

    # Create the target filename, full path. ._tmp -extension is used during the write
    timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S_')
    target_file = path + '/' + timestamp + backup.target_file
    target_file_tmp = path + '/' + timestamp + backup.target_file + '._tmp'

    # Construct the write part of overall dd-command.
    writecmd = '/usr/bin/dd of=' + target_file_tmp + ' bs=' + backup.block_size

    log.write(backup.name + ' write command:', 'D')
    log.write(writecmd, 'D')

    log.write('Full copy command;', 'D')
    log.write(readcmd + ' | ' + writecmd, 'N')

    # Split the command line options / process commands for subprocess.Popen command
    readsplit = shlex.split(readcmd)
    writesplit = shlex.split(writecmd)

    readproc = None
    writeproc = None
    linestoprint = []
    if not test:
        try:
            # Start the process providing the read stream
            readproc = subprocess.Popen(readsplit,
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE)

            # Pipe the read streams output to write streams input
            writeproc = subprocess.Popen(writesplit,
            stdin=readproc.stdout,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE)

            # Wait until the writing process finishes, and flush everything.
            writeproc.wait()
            writeproc.stdout.flush()

            linestoprint = readproc.stderr.readlines() + writeproc.stderr.readlines()
        except OSError as err:
            err_count += 1
            msg += 'Something went wrong with the read and write processes'
            print(err)
            return err_count, msg

    # Rename the target file to standard name.
    log.write('Renaming ' + target_file_tmp + ' to ' + target_file, 'D')
    log.write('mv ' + target_file_tmp + ' ' + target_file, 'N')
    if not test:
        os.rename(target_file_tmp, target_file)


    log.write(backup.name + ' : ' + backup.remote_file + ' successfully' \
        + 'backed up as ' + target_file, 'I')

    log.write('with following dd statistics', 'D')
    for line in linestoprint:
        log.write(line.decode('utf-8'), 'D')


    return err_count, msg

    # End of def run__remote_backup(backup, path, log, test)


# Run the main function
if __name__ == '__main__':
    main(sys.argv[1:])
