#!/usr/bin/python3
'''ssh image cloner, to clone images from remote host over ssh'''

###############################################################################
##                             ssh image cloner                              ##
##                                                                           ##
## Python program to clone images from remote host over ssh                  ##
## Author: mikali-ri                                                         ##
## Created: 2021-11-01                                                       ##
## License: GNU General Public License v3                                    ##
##                                                                           ##
###############################################################################


###############################################################################
## Imports                                                                   ##
###############################################################################
import os
import sys
import codecs
import datetime
import getopt
import subprocess
import shlex
import yaml
from yaml.scanner import ScannerError



###############################################################################
## Own modules                                                               ##
###############################################################################
from helpers import Logger
from helpers import CmdArguments
from helpers import validator
from helpers.clonerclasses import Backup, ConfigFile

###############################################################################
## My own custom classes                                                     ##
###############################################################################

#------------------------------------------------------------------------------
# Class for writing the logs, this handles the log levels etc.
#------------------------------------------------------------------------------
class LogWriter:
    '''A simple class to handle the verbosity and log writing'''

    def __init__(self, log_object, level, written, test):
        self.log = log_object
        self.log_level = level
        self.is_log_written = written
        if self.is_log_written and not test:
            with self.log.log_writer() as log_obj:
                log_obj.write_starting_row('Logging initiated, log level set to ' \
                     + str(self.log_level))


    def write(self, message, msgtype = 'N'):
        '''write a message to the log according to level etc.'''
        # if write_log is not set to True, do nothing.
        if not self.is_log_written:
            return

        if msgtype == 'E':
            with self.log.log_writer() as log_obj:
                log_obj.write_log(message, msgtype)
        elif msgtype == 'D' and self.log_level >= 2:
            with self.log.log_writer() as log_obj:
                log_obj.write_log(message, msgtype)
        elif msgtype == 'I' and self.log_level >= 1:
            with self.log.log_writer() as log_obj:
                log_obj.write_log(message, msgtype)
        elif msgtype == 'N':
            with self.log.log_writer() as log_obj:
                log_obj.write_log(message, msgtype)

        return


###############################################################################
## Constants                                                                 ##
###############################################################################

# config file is expected to be in the working directory
CONFIG_FILE_PATH = './sshimagecloner.yaml'


###############################################################################
## Main executable code                                                      ##
###############################################################################

def main(args):
    '''Main function to execute the code'''

    # Error count and message; used throughout the code.
    e_cnt = 0
    e_msg = ''

    # Parse and validate arguments (from command line), if any
    e_cnt, e_msg, cmd_args = parse_cmd_arguments(args)
    if e_cnt > 0:
        sys.exit(e_msg)

    # Read and parse the configuration file
    if cmd_args.conf_file is None:
        v_r = validator.file_read(CONFIG_FILE_PATH)
        if v_r.result:
            e_cnt, e_msg, conf, all_backups = parse_config_file(v_r.value)
        else:
            sys.exit(v_r.message)
    else:
        e_cnt, e_msg, conf, all_backups = parse_config_file(cmd_args.conf_file)

    # End execution if errors in parsing config file
    if e_cnt > 0:
        print('Errors in parsing the configuration file:\n')
        print(e_msg)
        sys.exit(1)

    # If run as configtest, end process here
    if cmd_args.configtest:
        print('Config file content seems to be OK!')
        sys.exit(0)

    # Set up logging
    log = None
    my_log = None
    if cmd_args.test:
        log = Logger(os.devnull, True)
        my_log = LogWriter(log, 0, True, True)
    else:
        log = Logger(conf.log_file, cmd_args.verbose)
        my_log = LogWriter(log, conf.log_level, conf.is_log_written, False)

    my_log.write('All arguments and parameters parsed successfully, found ' \
        + str(len(all_backups)) + ' backups from config file', 'D')

    my_log.write('Command line arguments are:', 'D')
    my_log.write(str(cmd_args), 'D')
    my_log.write('Configuration parameters are:', 'D')
    my_log.write(str(conf), 'D')
    my_log.write('Backups and parameters are:', 'D')
    my_log.write(str(all_backups), 'D')


    # Actual execution starts from here
    my_log.write('Start to execute backups', 'D')

    # Compare the command line arguments with config file backups
    backups_to_process = {}
    if len(cmd_args.backup_names) > 0:
        e_cnt, e_msg, backups_to_process = select_for_processing(cmd_args.backup_names, all_backups)
    else:
        backups_to_process = all_backups

    if e_cnt > 0:
        my_log.write(e_msg, 'E')
        print(e_msg)
        return

    my_log.write(str(len(backups_to_process)) + ' backups to be processed', 'I')


    # If target_folder is given from command line, then replace it for all backups to be processed
    if cmd_args.target_folder is not None:
        backups_to_process = replace_target_folder(backups_to_process, cmd_args.target_folder)

    # TODO Fix below, only the backup specific folder should be created, not the path before it

    # Process through the selected backups
    for key, backup in backups_to_process.items():
        # Check if the backup-specific folder exists, if not create
        e_cnt, e_msg, path = prepare_path(conf.root_folder,
            backup.target_folder,
            my_log,
            cmd_args.test)
        if  e_cnt > 0:
            my_log.write(key + ': ' + e_msg, 'E')
            print(e_msg)
            return
        # Run the backup
        e_cnt, e_msg = run_backup(backup, path, my_log, cmd_args.test)
        if e_cnt > 0:
            my_log.write(key + ': ' + e_msg, 'E')
            print(e_msg)
            return

    # TODO Loop through all backups, and remove those which exceed the allowed count

    # End of def main(args)



def parse_cmd_arguments(arg):
    '''Parse and validate command line arguments and return CmdArguments object'''

    usage = 'Usage: sshimagecloner [-h | --help] [-t | --test] [-v] \n' \
        + '[-c | --conffile configfile] [-f | --folder folder] \n' \
        + '[backupname_1] [backupname_2] [backupname...n]'

    err_count = 0
    msg = ''

    # Try to read the options and arguments from command line input
    try:
        opts, args = getopt.getopt(arg, 'htc:f:v', ['help', 'test', 'conffile=', 'folder='])
    except getopt.GetoptError:
        err_count += 1
        msg += '[ERROR] Could not parse command line options, possibly unrecognized option\n'
        msg += usage
        return err_count, msg, None

    # Check if asked for help, pring usage and exit
    for opt, val in opts:
        if opt in ('-h', '--help'):
            print(usage)
            sys.exit(0)

    # Process the options given.
    cmdargs = CmdArguments()

    for opt, val in opts:
        if opt == '-v':
            cmdargs.verbose = True
        elif opt in ('-c', '--conffile'):
            v_r = validator.file_read(val)
            if v_r.result:
                cmdargs.conf_file = v_r.value
            else:
                err_count +=1
                msg += v_r.message + '\n'
        elif opt in ('-f', '--folder'):
            v_r = validator.folder_write(val)
            if v_r.result:
                cmdargs.target_folder = v_r.value
            else:
                err_count +=1
                msg += v_r.message + '\n'
        elif opt in ('-t', '--test'):
            cmdargs.test = True
        else:
            err_count += 1
            msg += 'Unrecognized option'

    # Process the arguments given.
    for val in args:
        if val == 'configtest':
            cmdargs.configtest = True
        else:
            cmdargs.backup_names[val] = val

    return err_count, msg, cmdargs

    # End of def parse_cmd_arguments(arg)


def parse_config_file(path):
    '''Parse config file and return Configuration namedtuple object and backups -list'''
    msg = ''
    err_count = 0

    yaml_conf = {}

    # Try to read the config file, exit if it foes not work
    try:
        with codecs.open(path, 'r', 'utf-8') as config_file:
            yaml_conf = yaml.load(config_file, Loader=yaml.FullLoader)
    except ScannerError:
        sys.exit('ERROR! Configuration file could not be read in, check yaml syntax')


    # FIRST PARSE THE GENERAL CONFIGURATION
    general_config = {}
    if 'general' in yaml_conf:
        general_config = yaml_conf['general']
    else:
        err_count += 1
        msg += '[ERROR] general -section is missing from config file\n'

    e_c, e_m, conf = read_generalconfig_section(general_config)

    err_count += e_c
    msg += e_m

    # THEN PARSE THE BACKUP DETAILS
    backup_config = {}
    if 'backups' in yaml_conf:
        backup_config = yaml_conf['backups']
    else:
        err_count += 1
        msg += '[ERROR] backups -section is missing from config file\n'


    if len(backup_config) == 0:
        err_count += 1
        msg += '[ERROR] No backups specified in config file\n'

    e_c, e_m, all_backups = read_backupconfig_section(backup_config)

    err_count += e_c
    msg += e_m

    return err_count, msg, conf, all_backups
    # End of def parse_config_file(path)


def read_generalconfig_section(general_config):
    '''Read the general section from the configuration file yaml dict'''

    conf = ConfigFile()
    err_count = 0
    msg = ''

    #Check through all the parameters needed.
    if 'log_file' in general_config:
        v_r = validator.file_write(general_config['log_file'])
        if v_r.result:
            conf.is_log_written = True
            conf.log_file = v_r.value
        else:
            err_count += 1
            msg += v_r.message + '\n'

    if 'log_level' in general_config:
        v_r = validator.log_level(general_config['log_level'])
        if v_r.result:
            conf.log_level = v_r.value
        else:
            err_count += 1
            msg += v_r.message + '\n'

    if 'backup_root_folder' in general_config:
        v_r = validator.folder_write(general_config['backup_root_folder'])
        if v_r.result:
            conf.root_folder = v_r.value
        else:
            err_count += 1
            msg += v_r.message + '\n'
    else:
        err_count += 1
        msg += '[ERROR] Parameter backup_root_folder not set in config file\n'

    return err_count, msg, conf

    # End of read_generalconfig_section(general_config)

def read_backupconfig_section(backup_config):
    '''Read the backups section from the configuration yaml dict'''

    all_backups = {}
    err_count = 0
    msg = ''

    for key in backup_config:
        backup = Backup()

        v_r = validator.backup_name(key)
        if v_r.result:
            pass
        else:
            err_count += 1
            msg += v_r.message + '\n'

        backup.name = key

        try:
            v_r = validator.ip_address_or_host(backup_config[key]['remote_host'])
            if v_r.result:
                backup.remote_host = v_r.value
            else:
                err_count += 1
                msg += v_r.message + '\n'
        except KeyError:
            err_count += 1
            msg += '[ERROR] remote_host not specified for backup: ' + key + '\n'
        try:
            v_r = validator.remote_login(backup_config[key]['remote_login'])
            if v_r.result:
                backup.remote_login = v_r.value
            else:
                err_count += 1
                msg += v_r.message + '\n'
        except KeyError:
            if backup.remote_host == 'localhost':
                pass
            else:
                err_count += 1
                msg += '[ERROR] remote_login not specified for backup: ' + key + '\n'
        try:
            backup.remote_file = backup_config[key]['remote_file']
        except KeyError:
            err_count += 1
            msg += '[ERROR] remote_file not specified for backup: ' + key + '\n'
        try:
            v_r = validator.target_file(backup_config[key]['target_file'])
            if v_r.result:
                backup.target_file = v_r.value
            else:
                err_count += 1
                msg += v_r.message + '\n'
        except KeyError:
            err_count += 1
            msg += '[ERROR] target_file not specified for backup: ' + key + '\n'
        try:
            v_r = validator.versions(backup_config[key]['versions'])
            if v_r.result:
                backup.versions = v_r.value
            else:
                err_count += 1
                msg += v_r.message + '\n'
        except KeyError:
            pass

        backup.target_folder = backup.name

        all_backups[backup.name] = backup


    return err_count, msg, all_backups
    # End of def read_backupconfig_section(backup_config)


def select_for_processing(cmdback, allback):
    '''Select the backups to be processed based on cmdline arguments.'''
    err_count = 0
    msg = ''
    backups_to_process = {}
    for key in cmdback:
        if key in allback.keys():
            backups_to_process[key] = allback[key]
        else:
            err_count += 1
            msg += 'Backup: ' + key + ' not found from config file, aborting\n'

    return err_count, msg, backups_to_process
    # Enf of def select_for_processing(cmdback, allback)


# Method to replace the target folder of the backups.
def replace_target_folder(backups, folder):
    '''Function to replace the target folder'''

    for key, value in backups.items():
        backups[key] = value._replace(target_folder = folder)

    return backups
    # End of def replace_target_folder(backups, folder)


# Method to create (if needed) the full backup path and return that.
def prepare_path(root_path, folder, log, test):
    '''Function to return the full backup path, and create if it does not exist'''
    err_count = 0
    msg = ''

    backup_folder = root_path + '/' + folder

    if os.path.isdir(backup_folder):
        return 0, '', backup_folder
    else:
        if os.path.exists(backup_folder):
            err_count += 1
            msg += 'Backup path ' + backup_folder + ' already exists, but is not a directory'
            return err_count, msg, ''
        else:
            try:
                # FIXME Do not create the full structure, exit if root path does not exist!!
                log.write('Create the full directory stucture', 'D')
                log.write('mkdir -p' + backup_folder, 'N')
                if not test:
                    os.makedirs(backup_folder)
            except PermissionError:
                err_count += 1
                msg += 'Cannot create folder: ' + backup_folder + ', no access rights'
                return err_count, msg, ''

    return err_count, msg, backup_folder

    # End of def prepare_path(root_path, folder, log, test)

# Method to run one backup
def run_backup(backup, path, log, test):
    '''Function to process one backup'''
    err_count = 0
    msg = ''

    if backup.remote_host == 'localhost':
        err_count, msg = run_local_backup(backup, path, log, test)
    else:
        err_count, msg = run_remote_backup(backup, path, log, test)

    return err_count, msg
    # End of def def run_backup(backup, path, log, test)


# Method to run one local backup
def run_local_backup(backup, path, log, test):
    '''Function to process one backup from local machine'''
    err_count = 0
    msg = ''

    log.write('Starting to process localhost ' + backup.name + ' : ' + backup.remote_file, 'I')

    # Construct the read command
    readcmd = '/usr/bin/sudo /usr/bin/dd if='+ backup.remote_file + ' bs=4M'

    log.write(backup.name + ' read command:', 'D')
    log.write(readcmd, 'D')

    # Create the target filename, full path. ._tmp -extension is used during the write
    timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S_')
    target_file = path + '/' + timestamp + backup.target_file
    target_file_tmp = path + '/' + timestamp + backup.target_file + '._tmp'

    # Construct the write part of overall dd-command.
    gzipcmd = '/usr/bin/gzip -4'

    log.write(backup.name + ' gzip command:', 'D')
    log.write(gzipcmd, 'D')

    log.write('Full copy command:', 'D')
    log.write(readcmd + ' | ' + gzipcmd + ' > ' + target_file, 'N')

    # Split the command line options / process commands for subprocess.Popen command
    readsplit = shlex.split(readcmd)
    gzipsplit = shlex.split(gzipcmd)

    readproc = None
    gzipproc = None
    linestoprint = []
    if not test:
        try:
            outputfile = open(target_file_tmp, 'wb')
            # Start the process providing the read stream
            readproc = subprocess.Popen(readsplit,
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE)

            # Pipe the read streams output to write streams input
            gzipproc = subprocess.Popen(gzipsplit,
            stdin=readproc.stdout,
            stdout=outputfile,
            stderr=subprocess.PIPE)

            # Wait until the writing process finishes, and flush everything.
            gzipproc.wait()
            outputfile.flush()
            outputfile.close()

            linestoprint = readproc.stderr.readlines()
        except OSError as err:
            err_count += 1
            msg += 'Something went wrong with the read and write processes'
            print(err)
            return err_count, msg

    # Rename the target file to standard name.
    log.write('Renaming ' + target_file_tmp + ' to ' + target_file, 'D')
    log.write('mv ' + target_file_tmp + ' ' + target_file, 'N')
    if not test:
        os.rename(target_file_tmp, target_file)


    log.write(backup.name + ' : ' + backup.remote_file + ' successfully' \
        + 'backed up as ' + target_file, 'I')

    log.write('with following dd statistics', 'D')
    for line in linestoprint:
        log.write(line.decode('utf-8'), 'D')


    return err_count, msg
    # End of def run_local_backup(backup, path, log, test)


# Method to run one remote backup
def run_remote_backup(backup, path, log, test):
    '''Function to process one backup from a remote machine.'''
    err_count = 0
    msg = ''

    log.write('Starting to process remote host ' + backup.name + ' : ' + backup.remote_file, 'I')

    # Construct the "reading" part of the dd + gzip command
    readcmd = '/usr/bin/ssh ' + backup.remote_login + '@' + backup.remote_host \
        + ' "/usr/bin/sudo /usr/bin/dd if='+ backup.remote_file + ' bs=64k' \
        + ' | /usr/bin/gzip -4 -"'

    log.write(backup.name + ' read command:', 'D')
    log.write(readcmd, 'D')

    # Create the target filename, full path. ._tmp -extension is used during the write
    timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S_')
    target_file = path + '/' + timestamp + backup.target_file
    target_file_tmp = path + '/' + timestamp + backup.target_file + '._tmp'

    # Construct the write part of overall dd-command.
    writecmd = '/usr/bin/dd of=' + target_file_tmp + ' bs=64k'

    log.write(backup.name + ' write command:', 'D')
    log.write(writecmd, 'D')

    log.write('Full copy command;', 'D')
    log.write(readcmd + ' | ' + writecmd, 'N')

    # Split the command line options / process commands for subprocess.Popen command
    readsplit = shlex.split(readcmd)
    writesplit = shlex.split(writecmd)

    readproc = None
    writeproc = None
    linestoprint = []
    if not test:
        try:
            # Start the process providing the read stream
            readproc = subprocess.Popen(readsplit,
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE)

            # Pipe the read streams output to write streams input
            writeproc = subprocess.Popen(writesplit,
            stdin=readproc.stdout,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE)

            # Wait until the writing process finishes, and flush everything.
            writeproc.wait()
            writeproc.stdout.flush()

            linestoprint = readproc.stderr.readlines() + writeproc.stderr.readlines()
        except OSError as err:
            err_count += 1
            msg += 'Something went wrong with the read and write processes'
            print(err)
            return err_count, msg

    # Rename the target file to standard name.
    log.write('Renaming ' + target_file_tmp + ' to ' + target_file, 'D')
    log.write('mv ' + target_file_tmp + ' ' + target_file, 'N')
    if not test:
        os.rename(target_file_tmp, target_file)


    log.write(backup.name + ' : ' + backup.remote_file + ' successfully' \
        + 'backed up as ' + target_file, 'I')

    log.write('with following dd statistics', 'D')
    for line in linestoprint:
        log.write(line.decode('utf-8'), 'D')


    return err_count, msg

    # End of def run__remote_backup(backup, path, log, test)


# Run the main function
if __name__ == '__main__':
    main(sys.argv[1:])
